# _Домашнее задание 1:_ Преставление графов. DFS, BFS. Поиск кратчайшего пути.
## Контрольные вопросы:
1) Что такое граф? 
2) В случае _простого_ графа (отсутствуют _петли_ и _кратные ребра_), какое максимальное возможное количество ребер `M`? Зависит ли это число от _ориентированности_ графа?
3) Как по заданной матрице смежности быстро проверить граф на _орентированность_?
4) Как изменятся структуры списка ребер и списка смежности в случае _взвешенного_ графа?
5) Что такое _компонента связности_ графа? Каким может быть максимальное и минимальное кол-во _компонент_ в одном графе? 
6) Можно ли с помощью __BFS__ искать циклы в графе? Выгоднее ли это чем поиск через __DFS__?
7) Зачем вводится требование на неотрицательность _веса ребра_ в алгоритме __Дейкстры__? Можно ли заставить алгоритм корректно работать в случае отрицательных _весов_ (без их изменения).
8) Зачем запускать алгоритм __Форда-Беллмана__ в N-й раз? Почему в определенных случаях задача поиска кратчайщего пути в принципе некорректна на нашем графе?
9) Подумайте, в каком случае __Форд-Беллман__ может работать быстрее чем __Дейкстра__. Каким образом можно оптимизировать эту ситуацию?
10) В каких ситуациях вы предпочтете рекурсивную реализацию __DFS__ итеративной и наоборот? Эффективно ли применение списка в качестве стэка в итеративной версии? Что насчет очереди в случае __BFS__?
## Задания:
1) Считать _ориентированный_ граф в виде списка ребер. В первой строке на вход поступают числа `N` и `M` — количество вершин и ребер в графе соответственно. В следующих `M` строках поступают пары чисел, означающие вершины, связанные ребром.
2) Написать код, который по заданному числе вершин в графе `N` и списку ребер `edge_list`, возвращает матрицу смежности заданного графа. 
3) "Обернуть" матрицу смежности заданного графа. (То есть сделать так, чтобы каждое ребро в _ориентированном_ графе стало направленным в другую сторону). 
4) Посчитать количество компонент связности заданного _неориентированного_ графа обходом в ширину (__BFS__).
5) Написать _рекурсивный_ обход графа в глубину (__DFS__) с двойной печатью: номер вершины должен выводиться, когда алгоритм "входит" в вершину, и когда "выходит" из нее.
6) Реализовать алгоритм __Форда-Беллмана__.